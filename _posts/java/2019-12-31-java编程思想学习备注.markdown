---
layout: post
title:  "《java编程思想5》学习备忘!"
date:   2019-12-09 09:20:21 +0800
categories: 技术栈
---
**《Java编程思想》 第5版**

	地址：https://github.com/LingCoder/OnJava8
---
### 第六章 初始化和清理
* 利用构造器保证初始化

	构造器名称与类名相同。在初始化过程中自动调用构造器方法是有意义的。构造器没有返回值。
	
		class Rock {
	    	Rock() { // 这是一个构造器
	        System.out.print("Rock ");
	   	 }
		}
* 区分重载方法
	
	如果两个方法命名相同，Java是怎么知道你调用的是哪个呢？有一条简单的规则：每个被重载的方法必须有独一无二的参数列表。
	
* 无参构造器

	如果你创建一个类，类中没有构造器，那么编译器就会自动为你创建一个无参构造器。但是,一旦你显式地定义了构造器（无论有参还是无参），编译器就不会自动为你创建无参构造器。
	
* this关键字

	this 关键字只能在非静态方法内部使用。当你调用一个对象的方法时，this 生成了一个对象引用。你可以像对待其他引用一样对待这个引用。如果你在一个类的方法里调用其他该类中的方法，不要使用 this，直接调用即可，this 自动地应用于其他方法上了。

* 垃圾回收器

	当垃圾回收器准备回收对象的内存时，首先会调用其 finalize() 方法，并在下一轮的垃圾回收动作发生时，才会真正回收对象占用的内存。所以如果你打算使用 finalize() ，就能在垃圾回收时做一些重要的清理工作。对象可能不被垃圾回收；垃圾回收不等同于析构；垃圾回收只与内存有关。
	这里讨论的 Java 虚拟机中，内存分配以较大的"块"为单位。如果对象较大，它会占用单独的块。严格来说，"停止-复制"要求在释放旧对象之前，必须先将所有存活对象从旧堆复制到新堆，这导致了大量的内存复制行为。有了块，垃圾回收器就可以把对象复制到废弃的块。每个块都有年代数来记录自己是否存活。通常，如果块在某处被引用，其年代数加 1，垃圾回收器会对上次回收动作之后新分配的块进行整理。这对处理大量短命的临时对象很有帮助。垃圾回收器会定期进行完整的清理动作——大型对象仍然不会复制（只是年代数会增加），含有小型对象的那些块则被复制并整理。Java 虚拟机会监视，如果所有对象都很稳定，垃圾回收的效率降低的话，就切换到"标记-清扫"方式。同样，Java 虚拟机会跟踪"标记-清扫"的效果，如果堆空间出现很多碎片，就会切换回"停止-复制"方式。这就是"自适应"的由来，你可以给它个啰嗦的称呼："自适应的、分代的、停止-复制、标记-清扫"式的垃圾回收器。
	
---	
### 第七章 封装
通常，客户端程序员希望你的代码在某些方面保持不变。所以你想修改代码，但他们希望代码保持不变。由此引出了面向对象设计中的一个基本问题："如何区分变动的事物和不变的事物"。

这个问题对于类库而言尤其重要。类库的使用者必须依赖他们所使用的那部分类库，并且知道如果使用了类库的新版本，不需要改写代码。另一方面，类库的开发者必须有修改和改进类库的自由，并保证客户代码不会受这些改动影响。

这可以通过约定解决。例如，类库开发者必须同意在修改类库中的一个类时，不会移除已有的方法，因为那样将会破坏客户端程序员的代码。与之相反的情况更加复杂。

* 创建独一无二的包名
	
	一种合乎逻辑的做法是将特定包下的所有 .class 文件都放在一个目录下。也就是说，利用操作系统的文件结构的层次性。这是 Java 解决混乱问题的一种方式。
	
	按照惯例，package 名称是类的创建者的反顺序的 Internet 域名。如果你遵循惯例，因为 Internet 域名是独一无二的，所以你的 package 名称也应该是独一无二的，不会发生名称冲突。
	
* private: 你无法访问

	关键字 private 意味着除了包含该成员的类，其他任何类都无法访问这个成员。同一包中的其他类无法访问 private 成员，因此这等于说是自己隔离自己。另一方面，让许多人合作创建一个包也是有可能的。使用 private，你可以自由地修改那个被修饰的成员，无需担心会影响同一包下的其他类。
	
	注意，类既不能是 private 的（这样除了该类自身，任何类都不能访问它），也不能是 protected 的。所以对于类的访问权限只有两种选择：包访问权限或者 public。为了防止类被外界访问，可以将所有的构造器声明为 private，这样只有你自己能创建对象（在类的 static 成员中）
	
---
### 第八章 复用

* final关键字


	一个被 static 和 final 同时修饰的属性只会占用一段不能改变的存储空间。在 Java 中，这类常量必须是基本类型，而且用关键字 final 修饰。你必须在定义常量的时候进行赋值。static 强调只有一个，final 说明是一个常量。
	
	按照惯例，带有恒定初始值的 final static 基本变量（即编译时常量）命名全部使用大写，单词之间用下划线分隔。
	
	使用 final 方法的原因是给方法上锁，防止子类通过覆写改变方法的行为。这是出于继承的考虑，确保方法的行为不会因继承而改变。类中所有的 private 方法都隐式地指定为 final。
	
	当说一个类是 final （final 关键字在类定义之前），就意味着它不能被继承。之所以这么做，是因为类的设计就是永远不需要改动，或者是出于安全考虑不希望它有子类。然而，由于 final 类禁止继承，类中所有的方法都被隐式地指定为 final，所以没有办法覆写它们。
	
* 类初始化和加载

	记住每个类的编译代码都存在于它自己独立的文件中。该文件只有在使用程序代码时才会被加载。一般可以说“类的代码在首次使用时加载“。这通常是指创建类的第一个对象，或者是访问了类的 static 属性或方法。构造器也是一个 static 方法尽管它的 static 关键字是隐式的。因此，准确地说，一个类当它任意一个 static 成员被访问时，就会被加载。
	

	首次使用时就是 static 初始化发生时。所有的 static 对象和 static 代码块在加载时按照文本的顺序（在类中定义的顺序）依次初始化。static 变量只被初始化一次。
在加载过程中，编译器注意到有一个基类，于是继续加载基类。不论是否创建了基类的对象，基类都会被加载。（可以尝试把创建基类对象的代码注释掉证明这点。）

	如果基类还存在自身的基类，那么第二个基类也将被加载，以此类推。接下来，根基类（例子中根基类是 Insect）的 static 的初始化开始执行，接着是派生类，以此类推。这点很重要，因为派生类中 static 的初始化可能依赖基类成员是否被正确地初始化。

	至此，必要的类都加载完毕，可以创建对象了。首先，对象中的所有基本类型变量都被置为默认值，对象引用被设为 null —— 这是通过将对象内存设为二进制零值一举生成的。接着会调用基类的构造器。本例中是自动调用的，但是你也可以使用 super 调用指定的基类构造器（在 Beetle 构造器中的第一步操作）。基类构造器和派生类构造器一样以相同的顺序经历相同的过程。当基类构造器完成后，实例变量按文本顺序初始化。最终，构造器的剩余部分被执行。
	
---
### 多态

* 方法调用绑定

	将一个方法调用和一个方法主体关联起来称作绑定。若绑定发生在程序运行前（如果有的话，由编译器和链接器实现），叫做前期绑定。你可能从来没有听说这个术语，因为它是面向过程语言不需选择默认的绑定方式，例如在 C 语言中就只有前期绑定这一种方法调用。
	
	上述程序让人困惑的地方就在于前期绑定，因为编译器只知道一个 Instrument 引用，它无法得知究竟会调用哪个方法。

	解决方法就是后期绑定，意味着在运行时根据对象的类型进行绑定。后期绑定也称为动态绑定或运行时绑定。当一种语言实现了后期绑定，就必须具有某种机制在运行时能判断对象的类型，从而调用恰当的方法。也就是说，编译器仍然不知道对象的类型，但是方法调用机制能找到正确的方法体并调用。每种语言的后期绑定机制都不同，但是可以想到，对象中一定存在某种类型信息。

	Java 中除了 static 和 final 方法（private 方法也是隐式的 final）外，其他所有方法都是后期绑定。这意味着通常情况下，我们不需要判断后期绑定是否会发生——它自动发生。

	为什么将一个对象指明为 final ？正如前一章所述，它可以防止方法被重写。但更重要的一点可能是，它有效地”关闭了“动态绑定，或者说告诉编译器不需要对其进行动态绑定。这可以让编译器为 final 方法生成更高效的代码。然而，大部分情况下这样做不会对程序的整体性能带来什么改变，因此最好是为了设计使用 final，而不是为了提升性能而使用。
	
* 陷阱：“重写”私有方法

		// polymorphism/PrivateOverride.java
		// Trying to override a private method
		// {java polymorphism.PrivateOverride}
		package polymorphism;
	
		public class PrivateOverride {
	    	private void f() {
	        	System.out.println("private f()");
	    }
	    
	    public static void main(String[] args) {
	        PrivateOverride po = new Derived();
	        po.f();
	    }
		}
	
		public Derived extends PrivateOverride {
	    public void f() {
	        System.out.println("public f()");
	    }
		}
		
	输出：
	
		private f()
		
你可能期望输出是 public f()，然而 private 方法也是 final 的，对于派生类来说是隐蔽的。因此，这里 Derived 的 f() 是一个全新的方法；因为基类版本的 f() 屏蔽了 Derived ，因此它都不算是重写方法。

结论是只有非 private 方法才能被重写，但是得小心重写 private 方法的现象，编译器不报错，但不会按我们所预期的执行。为了清晰起见，派生类中的方法名采用与基类中 private 方法名不同的命名。

如果使用了 @Override 注解，就能检测出问题。

* 构造器调用顺序

	在派生类的构造过程中总会调用基类的构造器。初始化会自动按继承层次结构上移，因此每个基类的构造器都会被调用到。这么做是有意义的，因为构造器有着特殊的任务：检查对象是否被正确地构造。由于属性通常声明为 private，你必须假定派生类只能访问自己的成员而不能访问基类的成员。只有基类的构造器拥有恰当的知识和权限来初始化自身的元素。因此，必须得调用所有构造器；否则就不能构造完整的对象。这就是编译器强制每个派生类部分必须调用构造器的原因。如果在派生类的构造器主体中没有显式地调用基类构造器，编译器就会默默地调用无参构造器。如果没有无参构造器，编译器就会报错（当类中不含构造器时，编译器会自动合成一个无参构造器）。
	Glyph() before draw()
	Glyph.draw()
	Glyph() after draw()
	RoundGlyph.RoundGlyph(), radius = 5

* 构造器内部多态方法的行为

		// polymorphism/PolyConstructors.java
		// Constructors and polymorphism
		// don't produce what you might expect
		class Glyph {
		   		 void draw() {
	        	System.out.println("Glyph.draw()");
	    	}

    	Glyph() {
        System.out.println("Glyph() before draw()");
        draw();
        System.out.println("Glyph() after draw()");
    	}
		}

		class RoundGlyph extends Glyph {
	    private int radius = 1;

	    RoundGlyph(int r) {
	        radius = r;
	        System.out.println("RoundGlyph.RoundGlyph(), radius = " + radius);
	    }

	    @Override
	    void draw() {
	        System.out.println("RoundGlyph.draw(), radius = " + radius);
	    }
		}
	
		public class PolyConstructors {
	    public static void main(String[] args) {
	        new RoundGlyph(5);
	    }
		}
		
输出：

	Glyph() before draw()
	RoundGlyph.draw(), radius = 0
	Glyph() after draw()
	RoundGlyph.RoundGlyph(), radius = 5
	
初始化的实际过程是：

在所有事发生前，分配给对象的存储空间会被初始化为二进制 0。
如前所述调用基类构造器。此时调用重写后的 draw() 方法（是的，在调用 RoundGraph 构造器之前调用），由步骤 1 可知，radius 的值为 0。
按声明顺序初始化成员。最终调用派生类的构造器。

